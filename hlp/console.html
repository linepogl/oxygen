<!DOCTYPE html><html><head><meta charset="UTF-8" />
<title>Oxygen documentation</title>
<link rel="stylesheet" type="text/css" href="index.css" />
</head><body>



<h1>The developer console</h1>

<p>
Oxygen comes with a limited but helpful set of tools to assist in the development process. These tools can be found in the development console, which is nothing but a standard <span class="code">Action</span>.
So, the console can be accessed from the standard URL with the query string paramenter <b>action=Oxygen</b>.
</p>

<p>
The first screen in the developer console is an information page with all the setup parameters of Oxygen. Then, there are 3 tabs with reports. On the othe side of the bar, there is a button to reset the cache,
a button to access the documentation and a button to return to the application.
</p>

<p>
The 3 reporting tabs are browsers for reports generated by Oxygen and kept as files in the log folder. There are links to view or to delete reports. Each of the reports have a header that contains a copy of
the info page at the moment the report was generated.
</p>

<h2>Error reports</h2>

<p>
Error reports are generated automatically by Oxygen whenever an exception (other than <span class="code">ApplicationException</span> or <span class="code">SecurityException</span>) is caught by the exception
handler. If the application runs on a production environment, a copy of the report is also sent to each of the developers. The type of the environment is only determined by the URL of the application; if it
runs under 'localhost', then it is <b>DEVELOPMENT</b>. In any other case, it is considered <b>PRODUCTION</b>. The error reports are accumulated here even in a development environment. This is just to keep
track of possible open bugs.
</p>



<h2>Debugger reports</h2>

<p>
Debugger reports is a sophisticated way to generate logs from the code to assist in debugging. They serve as a replacement to the <span class="code">error_log</span> function of PHP. The debugger come with some
functions that make the creation of logs easier.
</p>

<p>
To write something to the debugger, use the function <span class="code">Debug::Write()</span>. Every entry in the debugger will automatically take two attributes: the time passed from the beginning of the script's
execution and the time from the previous debugger entry.
</p>

<p class="code">
Debug::Write('Beginning processing...');
...
Debug::Write('Processing finished.');
</p>

<p>
There are also some others similar functions. <span class="code">Debug::Tick()</span> will write nothing but a bullet to the log, which is sometimes useful in order to start timing up to the next entry.
In addition, <span class="code">Debug::Dump</span> will dump the value of a variable, along with its type (similar to <span class="code">var_dump</span>, but with less noise).
</p>

<p class="code">
Debug::Tick();
...
Debug::Dump( $v );  // this will dump the variable, and it will show the time since the last entry (the tick).
...
</p>

<p>
The debugger report will not be created unless the debugger is enabled. To enable the debugger, add the query string parameter <b>debug</b> to the address and the debugger report will show up and a copy will be
saved in to the log folder. There is also the option to keep the debugger running in every consequent request by pinning the parameter. To do so, use <b>debug=pin</b>. This is very useful in order to debug actions
that are not called directly from the address bar, such as AJAX requests, or other BLIND actions such as file servers. The report will be generated and save in the log folder even it it is not possible to show
up immediately.
</p>

<p class="warning">
While the debugger is a nice ad-hoc solution, it should not be considered as a replacement for a full blown IDE with a PHP debugger. Being professional means that one should having all the tools ready to be used
and select the best tool for each case.
</p>


<h2>Profiler</h2>

<p>
Oxygen comes with a profiler, which is a slightly modified fork of <a class="external" href="http://pecl.php.net/package/xhprof">XHProf</a>.
</p>

<p>
Setting up the profiler is a little tricky as it implies compiling the profiler as a PHP extension and including it in the php.ini. The code for the compiler can be found inside the folder <b>oxy/ext/xhprof fork</b>.
Compiling an extension is a standard procedure described in <a class="external" href="http://php.net/manual/en/install.pecl.phpize.php">http://php.net/manual/en/install.pecl.phpize.php</a>.
</p>

<p>
Once set up, the profiler can be called the same way as the debugger by adding the query string parameter <b>profile</b> or <b>profile=pin</b>. The process is similar, the profiler report will be shown immediatelly
if possible and a copy will be saved in the log folder.
</p>

<p>
The profiler is configured to work in instrumentation mode (which means tracking the entrance and the exit to each function, in constast to the sampling mode) and it ignores the calls to internal function (their
time is added to the caller function). It shows the total number of calls to each function and the total time spent in the function inclusively and exclusively. The later is probably to most important hint for
the point in the application that need optimising.
</p>

<p class="warning">
Always remember that premature optimisation is the mother of all evil.
</p>




<footer>
<a href="index.html">&larr; Table of contents</a>
</footer>

</body></html>